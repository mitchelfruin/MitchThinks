---
title: "Estimating Pi 2000 years too late."
author: "Mitchel Fruin"
date: "2020-05-08"
description: "Comparing Archimedes' estimate of Pi with Rchimedes estimate."
tags: 
slug: estimate_pi
draft: true
output:
  blogdown::html_page:
    toc: true
    toc_depth: 2
    number_sections: true
---

<style type="text/css">
div#TOC li {
    list-style:none;
    background-image:none;
    background-repeat:none;
    background-position:0; 
}
</style>

```{r setup, include=FALSE}
# RMarkdown
knitr::opts_chunk$set(echo = FALSE,
                      warning = FALSE,
                      message = FALSE,
                      fig.align = "center",
                      fig.width = 8.09,
                      fig.height = 5)

# Packages
library(tidyverse)
library(scales)
library(ggforce)
```

A couple of month's ago I read Steven Strogatz's Inifinite Powers.

It's a good book overall but the first half is great. I'd recommend it to anyone who ever asked, "but, like, why?" in a maths class in secondary school and didn't get a good answer (typically either a 'don't interrupt me' look or worse, "because it is"). 

My two favourite sections invovled Storgatz recounting how Archimedes discovered the formula for the area of a circle and how he estimated $\pi$. This post will only cover the latter. The reason being that there's a popular data science interview question which requires the applicant to estimate $\pi$. So, I thought it would be fun to compare Archimedes' estimate to what I'll be (shamelessly and repeatedly) calling **R**chimedes' estimate.

# Archimedes' estimate

$\pi$ is defined as the ratio between the circumference and diameter of a circle

$$\pi = \frac{C}{d}$$

We know that the diameter is twice the radius:

$$d = 2r$$

So, we know that we can write:

$$\pi = \frac{C}{2r}$$

What we need is an estimate for C. 

If we approximate the circumference of a circle using a hexagon inside it (as shown in the image below), then we know that (because a hexagon is 6 equilateral triangles) the distance around the edge of the hexagon (in bold) is $6r$.  

<center>
![Internal hexagon for lower bound.](/images/pi_hexagon_in.png)
</center>

So, if we know that 6 times the radius is an underestimate of the circumference of the circle, then we can write:

$$C > 6r$$

If we substitue this into our previous formula for $\pi$ we get:

$$\pi = \frac{C}{2r} > \frac{6r}{2r} = 3$$

In other words, we get a lower bound for the true value of $\pi$. We know it must be larger than 3. 

If you carry out the same process with a hexagon that is outside the circle, then we can get an upper bound for $\pi$. 

<center>
![External hexagon for upper bound](/images/pi_hexagon_out.png)
</center>

Staggeringly, Archimedes carried out a process equivalent to the one we just played through with a hexagon on a 96-sided shape and found the following interval:

$$3\frac{10}{70} < \pi < 3\frac{10}{71}$$

This means he found $\pi$ correct to 2 decimal places, $3.14$, which is as much  precision as most people know $\pi$ to nowadays.

# **R**chimedes' estimate

Ok, you're dressed to impress, you've politely said yes to a tea because you read a social psychology paper once that said interviewers preferred candidates that did, and you can feel a few beads of nervous sweat on the small of your back. You sit down at the interview table and the interviewer hands you a laptop with a set of instructions already open:

> You have a function which takes the input $n$ and outputs $n$ random numbers between 0 and 1. Estimate the value of $\pi$.

After the customary moment of panic, you decide actually think it through. 

Well, the easiest way you can think of to estimate $\pi$ is to find the area of a circle with a radius of $1$. 

After all,

$$\begin{aligned}
\text{Area of a circle} &= \pi \times \text{radius}^2 \\
\end{aligned}$$

So if $\text{radius} = 1$, then 

$$\begin{aligned}
\text{Area of a circle} &= \pi \times 1^2 \\
&= \pi
\end{aligned}$$

Alright, so what would a circle with radius of 1 look like?

```{r, fig.width = 5, fig.height = 5}
circle_coords <- function(center = c(0, 0), radius = 1, n_points = 1000) {
    centre_angle <- seq(0, 2*pi, length.out = n_points)
    x_coord <- center[1] + radius * cos(centre_angle)
    y_coord <- center[2] + radius * sin(centre_angle)
    tibble(x = x_coord, y = y_coord)
}

r_1 <- circle_coords()

r_1 %>%
  ggplot(aes(x = x, y = y)) +
  geom_point(size = 0.5, col = "#440154FF") +
  geom_vline(aes(xintercept = 0)) +
  geom_hline(aes(yintercept = 0)) +
  theme_minimal()
```

How does this help us? Well, if we use the random number function twice we can generate pairs of random coordinates. Let's plot 100 such coordinates:

```{r}
set.seed(1)
random_xy <- tibble(x = runif(100), y = runif(100)) %>%
  mutate(o_dist = sqrt(x^2 + y^2),
         in_circle = if_else(o_dist <= 1, T, F))
```

```{r, fig.width = 5, fig.height = 5}
random_xy %>%
  ggplot(aes(x = x, y = y)) +
  geom_point() +
  theme_minimal()
```

Now, if we superimpose our random pairs of coordinates onto our circle with radius 1:

```{r, fig.width = 5, fig.height = 5}
r_1 %>%
  ggplot(aes(x = x, y = y)) +
  geom_point(size = 0.5, col = "#440154FF") +
  geom_point(data = random_xy, aes(x = x, y = y)) +
  geom_vline(aes(xintercept = 0)) +
  geom_hline(aes(yintercept = 0)) +
  theme_minimal()
```

Hopefully the plan is starting to become clear. 

We need to calculate the proportion of random points that are inside the circle. 

```{r, fig.width = 5, fig.height = 5}
r_1 %>%
  ggplot(aes(x = x, y = y)) +
  geom_point(size = 0.5, col = "#440154FF") +
  geom_point(data = random_xy, aes(x = x, y = y, col = in_circle)) +
  geom_vline(aes(xintercept = 0)) +
  geom_hline(aes(yintercept = 0)) +
  scale_color_manual(guide = "none",
                     values = c("#31688EFF", "#FDE725FF")) +
  theme_minimal()
```

```{r}
prop_inside <- mean(random_xy$in_circle)
pi_estimate <- 4*prop_inside
```

In this instance, the proportion of our random points that fall inside the circle is `r prop_inside`. 

So, to find an estimate for the area of the circle (which we know to be $\pi$) all we have to do is multiply that proportion by 4. In this case, our estimate for $\pi$ turns out to be `r pi_estimate`. 

That's an ok estimate but, what if we want a greater degree of accuracy? All we need to do is use more random points. 

Say we ran through the whole process again but this time with 1000 points:

```{r, fig.width = 5, fig.height = 5}
set.seed(1)
random_xy <- tibble(x = runif(1000), y = runif(1000)) %>%
  mutate(o_dist = sqrt(x^2 + y^2),
         in_circle = if_else(o_dist <= 1, T, F))

r_1 %>%
  ggplot(aes(x = x, y = y)) +
  geom_point(size = 0.5, col = "#440154FF") +
  geom_point(data = random_xy, aes(x = x, y = y, col = in_circle)) +
  geom_vline(aes(xintercept = 0)) +
  geom_hline(aes(yintercept = 0)) +
  scale_color_manual(guide = "none",
                     values = c("#31688EFF", "#FDE725FF")) +
  theme_minimal()
```

```{r}
prop_inside <- mean(random_xy$in_circle)
pi_estimate <- 4*prop_inside
```

Now, the proportion of points inside the circle is `r prop_inside` giving us an estimate for $\pi$ of `r pi_estimate`. `R` provides the value of $\pi$ to 6 decimal places as `r pi`. We're getting closer. 

# Can we beat a guy whose been dead for 2000 years?

```{r}
R_chimedes <- function(n_points) {
  # Generate random pair of coordinates between 0 and 1
  x <- runif(n_points)
  y <- runif(n_points)
  # For each pair find distance from the origin
  o_dist <- sqrt(x^2 + y^2)
  # If o_dist <= 1, then inside or on circle
  in_or_out <- o_dist <= 1
  # Estimate pi
  4 * mean(in_or_out == TRUE)
}
```

How many random points do we need before we are more accurate than Archimedes?

Lets try a few different powers of 10.

```{r}
set.seed(1)
estimates <- tibble(n_points = 10^(2:8),
                    attempt_1 = map_dbl(n_points, R_chimedes),
                    attempt_2 = map_dbl(n_points, R_chimedes),
                    attempt_3 = map_dbl(n_points, R_chimedes)) %>%
  pivot_longer(cols = -n_points, names_to = "Estimate") %>%
  mutate(pi_6dp = pi,
         archimedes_low = 3 + 10/71,
         archimedes_high = 3 + 10/70)
```

```{r}
estimates %>%
  ggplot(aes(x = n_points, y = value)) +
  geom_ribbon(aes(ymin = archimedes_low, ymax = archimedes_high),
              fill = "#440154FF",
              alpha = 0.2) +
  geom_line(aes(y = pi_6dp), col = "#440154FF", lty = 2) +
  geom_point(aes(shape = Estimate, col = Estimate), size = 1.5) +
  scale_x_log10("No. of random points",
                breaks = 10^(2:8),
                labels = trans_format("log10", math_format(10^.x))) +
  scale_y_continuous("Value") +
  scale_color_manual(values = c("#31688EFF", "#35B779FF", "#FDE725FF")) +
  labs(caption = "The dashed purple line is pi to 6 dp.\nThe purple band is the range Archimedes calculated.") +
  theme_minimal() +
  theme(axis.title.y = element_text(angle = 0, vjust = 0.5))
```

```{r}
estimates %>%
  ggplot(aes(x = n_points, y = value)) +
  geom_ribbon(aes(ymin = archimedes_low, ymax = archimedes_high),
              fill = "#440154FF",
              alpha = 0.2) +
  geom_line(aes(y = pi_6dp), col = "#440154FF", lty = 2) +
  geom_point(aes(shape = Estimate, col = Estimate), size = 1.5) +
  scale_x_log10("No. of random points",
                breaks = 10^(6:8),
                labels = trans_format("log10", math_format(10^.x)),
                limits = c(10^6, 10^8)) +
  scale_y_continuous("Value", limits = c(3.139, 3.145)) +
  scale_color_manual(values = c("#31688EFF", "#35B779FF", "#FDE725FF")) +
  labs(caption = "The dashed purple line is pi to 6 dp.\nThe purple band is the range Archimedes calculated.") +
  theme_minimal() +
  theme(axis.title.y = element_text(angle = 0, vjust = 0.5))
```

# Knowing vs. Understanding

About undersatdning vs. knowing.

For a long time, definitely throughout all of school, all I really did was *know* stuff. Now, I want to *understand* stuff. And even if that means there's less stuff involved, I'm fine with that. Value of understanding is that you begin to see connections between seemingly disparate points of *knowledge*.